;; #include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

;; 2 <= N <= 31 & 2 <= M <= 31
;; 
;; The main idea: dijkstra with priority queue
;;
;;             min (X)       min (Q)   min (L)
;; sort by: (X to break, ? on the way, length)
;; memo: memo[i][j] = (X, Q, L, step back): best result to reach (i, j)

;; S = 83
;; X = 88
;; . = 46
;; E = 69
;; ? = 63
;; ! = 33

forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> int is_null?(X x) asm "ISNULL";
(cell, (int, slice, int)) ~udict::delete_get_min::custom(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN";
(slice, int) udict_get?::custom(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET";
forall X -> (tuple, ()) ~tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
forall X -> tuple tuples::tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";

;; X    Q    L   maze
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    (int si, int sj) = (0, 0);
    (int ei, int ej) = (0, 0);
    int i = 0;
    ;; int inf = 1099511626752;  ;; 0b1111111111 1111111111 1111111111 0000000000
    tuple memo = empty_tuple();
    repeat (n) {
        int j = 0;
        tuple memo_row = empty_tuple();
        tuple row = maze.at(i);
        repeat (m) {
            int char = row.at(j);
            if (char == 83) {
                (si, sj) = (i, j);
            } elseif (char == 69) {
                (ei, ej) = (i, j);
            }
            memo_row~tpush(1099511626752);  ;; INF: 0b1111111111 1111111111 1111111111 0000000000
            j += 1;
        }
        memo~tpush(memo_row);
        i += 1;
    }
    memo~tset(si, tuples::tset(memo.at(si), sj, 0));  ;; memo[si][sj] = 0
    tuple d = to_tuple([
        to_tuple([-1, -1]),
        to_tuple([-1,  0]),
        to_tuple([-1,  1]),

        to_tuple([ 0, -1]),
        to_tuple([ 0,  1]),

        to_tuple([ 1, -1]),
        to_tuple([ 1,  0]),
        to_tuple([ 1,  1])
    ]);

    int flatten_start = (si << 5) | sj;

    builder emptyb = begin_cell();
    cell queue = new_dict();
    queue~udict_set_builder(40, flatten_start, emptyb);
    do {
        (int current_key, slice cs, _) = queue~udict::delete_get_min::custom(40);
        int nxt_pos = current_key & ((1 << 10) - 1); current_key >>= 10;

        int i = nxt_pos >> 5;
        int j = nxt_pos & ((1 << 5) - 1);

        int dit = 0;
        repeat (8) {
            tuple dd = d.at(dit);
            (int dx, int dy) = (dd.at(0) + i, dd.at(1) + j);

            if ((dx >= 0) & (dx < n) & (dy >= 0) & (dy < m)) {
                int char = maze.at(dx).at(dy);
                int sub_key = current_key;

                sub_key += 1;  ;; L + 1
                if (char == 88) { sub_key += 1 << 20; } elseif (char == 63) { sub_key += 1 << 10; }
                int flatten_pos = (dx << 5) | dy;

                tuple dx_row = memo.at(dx);
                int old_key = dx_row.at(dy) >> 10;
                if (sub_key < old_key) {
                    dx_row~tset(dy, (sub_key << 10) | nxt_pos);
                    memo~tset(dx, dx_row);
                    queue~udict_set_builder(40, (sub_key << 10) | flatten_pos, emptyb);
                }
            }
            dit += 1;
        }
    } until (is_null?(queue));

    int key = memo.at(ei).at(ej);
    int sb = key & ((1 << 10) - 1); key >>= 10;
    int  L = key & ((1 << 10) - 1); key >>= 10;
    int  Q = key & ((1 << 10) - 1); key >>= 10;
    int  X = key;

    repeat (L - 1) {
        int i = sb >> 5;
        int j = sb & ((1 << 5) - 1);
        tuple row = maze.at(i);
        row~tset(j, 33);
        maze~tset(i, row);

        int key = memo.at(i).at(j);
        sb = key & ((1 << 10) - 1);
    }
    return (X, Q, L, maze);
}
